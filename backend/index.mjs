import express from 'express';
import 'dotenv/config';
import { check, validationResult } from 'express-validator';
import { MongoClient, ObjectID, } from 'mongodb';
import _ from 'lodash';
import session from 'express-session';
import 'express-async-errors';
import multer from 'multer';
import bcrypt from 'bcrypt';

const dbo = await MongoClient.connect('mongodb://127.0.0.1:27017')
    .catch(err => console.error('Failed to make MongoDB connection', err))
    .then(db => db.db('instaclone'));

if(!dbo)
    process.exit(1);

const escapeRegex = (text) => {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
};

const app = express();
const saltRounds = 10;

app.use(session({ secret: process.env.SECRET, resave: false, saveUninitialized: true }));
app.use(express.json());
const upload = multer({ dest: "uploads/" });
app.use('/uploads', express.static('uploads'))

// TODO: There are several problems with this function
// * The image name/id should be generated by MongoDB not multer
// * If the image fails it should'nt save to disk
// * The image should be checked to make sure it's actually an image
app.post('/upload', upload.single('image'), async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    await dbo.collection('posts')
        .insertOne({
            image: req.file.filename,
            uploaded: new Date(),
            author: req.session.username,
        }).catch(err => console.error(err));

    res.json({ message: req.file.filename });
});

app.post('/login', async (req, res) => {
    let user = await dbo.collection('users')
        .findOne({ _id: req.body.username.toLowerCase()});

    if(!user)
        return res
            .status(422)
            .json({ message: "User with specified name does not exist." });

    let matches = await bcrypt.compare(req.body.password, user.password)
        .catch(err => console.error(err));

    if(!matches)
        return res
            .status(422)
            .json({ message: "Username or password incorrect." });

    req.session.username = user._id;
    res.json({ message: "User successfully logged in" });
});

app.post('/logout', async (req, res) => {
    req.session.destroy();
    res.json({ message: "user successfully logged out" });
});

app.get('/users/:search?', async (req, res) => {
    let user;

    if(req.session.username)
        user = await dbo.collection('users').findOne({ _id: req.session.username });

    let following = req.session.username ? user.following || []: [] ;
    const regex = new RegExp(escapeRegex(req.params.search || ''), 'gi');

    let users = await dbo.collection('users')
        .aggregate([
            { $match: { _id: { $ne: req.session.username || '' } } },
            { $match: { $or: [ { _id: { $regex: regex } }, { displayName: { $regex: regex } } ] } },
            { $project: { following: { $in: ['$_id', following] }, displayName: '$displayName' } }
        ]).toArray();

    res.json(users);
});

app.get('/user', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let user = await dbo.collection('users').findOne({ _id: req.session.username });

    res.json(user);
});

const isUsernameTaken = async (username) => {
    let ret = await dbo.collection('users').findOne({ _id: username });

    return !_.isEmpty(ret);
};

app.post('/user',
    [
        check('username')
            .isAlphanumeric()
            .withMessage('Username must be only alphanumeric characters.')
            .isLength({ min: 3, max: 16 })
            .withMessage('Username must be between 3 and 12 characters long.'),
        check('email')
            .isEmail()
            .withMessage('Email must be valid email.'),
        check('password')
            .isLength({ min: 6, max: 24 })
            .withMessage('Password must be between 6 and 24 characters long.'),
        check('displayName')
            .matches(/^[\w\s]+$/)
            .withMessage('Display name must be only alphanumeric characters and space.')
            .isLength({ min: 2, max: 24 })
            .withMessage('Display name must be between 2 and 24 characters long.'),
    ],
    async (req, res) => {
        const errors = validationResult(req);

        if (!errors.isEmpty())
            return res.status(422)
                .json({ message: errors.array().map((a) => a.msg).join('\n') })

        const user = _.pick(req.body, 'username', 'email', 'password', 'displayName');
        user._id = user.username.toLowerCase();
        delete user.username;

        user.password = await bcrypt.hash(req.body.password, saltRounds);
        user['visibility'] = 'public';

        if(await isUsernameTaken(req.body.username))
            return res.status(422)
                .json({ message: 'Username already taken' });

        let ret = await dbo.collection('users')
            .insertOne(user);

        return res.json({ 'message': 'User created successfully' });
    }
);

const posts = async (query, username) => {
    return await dbo.collection('posts')
        .aggregate([
            { $match: query },
            { $lookup: { from: 'users', localField: 'author', foreignField: '_id', as: 'userInfo' } },
            { $unwind: '$userInfo' },
            { $match: {
                $or: [
                    { 'userInfo.visibility': 'public' },
                    { $and: [
                        { 'userInfo.visibility': 'following' },
                        { 'userInfo.following': { '$in': [ username ] } }
                    ] },
                    { 'userInfo._id': username }
                ]
            } },
            { $lookup: {
                from: 'likes',
                let: { 'post': '$_id' },
                pipeline: [
                    { $match: { $expr: { $eq: [ '$$post', '$post' ] } } },
                ],
                as: 'likes'
            } },
            { $lookup: {
                from: 'likes',
                let: { 'post': '$_id', 'user': username },
                pipeline: [
                    { $match: {
                        $expr: {
                            $and: [
                                { $eq: [ '$$post', '$post' ] },
                                { $eq: [ '$$user', '$user' ] }
                            ]
                        }
                    } }
                ],
                as: 'hasLiked'
            } },
            { $project: {
                _id: "$_id",
                author: '$author',
                image: '$image',
                uploaded: '$uploaded',
                displayName: '$userInfo.displayName',
                likes: { $size: '$likes' },
                hasLiked: { $ne: [ '$hasLiked', []] }
            } },
            { $sort: { uploaded: -1 } }
        ])
        .toArray();
}

app.get('/posts/:username', async (req, res) => {
    res.json(await posts({ author: req.params.username }, req.session.username));
});

// Get the posts of the users that being followed
app.get('/posts', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let data = await dbo.collection('users').findOne({ _id: req.session.username })
        .catch(err => console.error(err));

    if(!data)
        return res.status(500)
            .json({ message: 'Internal server error' })

    if(data.following && data.following.length > 0)
        res.json(await posts({ $or: data.following.map((id) => ({ author: id })) }, req.session.username));
    else
        res.json([])
});

app.post('/like', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let data = {
        // Prevent duplicate follows
        user: req.session.username,
        post: new ObjectID(req.body.post),
    };

    let like = await dbo.collection('likes').findOne(data)
        .catch((err) => console.error(err));

    if(like)
        return res.status(422)
            .json({ message: 'User already liked' });

    await dbo.collection('likes')
        .insertOne(data)
        .catch((err) => console.error(err));

    res.json({ message: 'Successful' });
});

app.post('/unlike', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let data = {
        // Prevent duplicate follows
        user: req.session.username,
        post: new ObjectID(req.body.post),
    };

    let like = await dbo.collection('likes').findOne(data)
        .catch((err) => console.error(err));

    if(!like)
        return res.status(422)
            .json({ message: 'User has not liked' });

    await dbo.collection('likes')
        .deleteOne(data)
        .catch((err) => console.error(err));

    res.json({ message: 'Successful' });
});

app.post('/follow', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let followee = req.body.username.toLowerCase();

    await dbo.collection('users').updateOne(
        {
            _id: req.session.username,
            // Prevent duplicate follows
            following: { $ne: followee }
        },
        { $push: { following: followee } }
    );

    res.json({ message: 'Successful' });
});

app.post('/unfollow', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    let followee = req.body.username.toLowerCase();

    await dbo.collection('users').updateOne(
        { _id: req.session.username },
        { $pull: { following: followee } }
    );

    res.json({ message: 'Successful' });
});

app.post('/settings', async (req, res) => {
    if(!req.session.username)
        return res.status(401)
            .json({ message: 'User not logged in' });

    await dbo.collection('users').updateOne(
        { _id: req.session.username },
        { $set: {
            visibility: req.body.visibility,
            displayName: req.body.displayName,
        } }
    );

    res.json({ message: 'User settings updated successfully.' });
});

app.use((err, req, res, next) => {
    console.log();
    res.status(500)
        .json(process.env.NODE_ENV === 'production' ?
            { message: 'Interal server error.' }
            : { message: `${err}` }
        )
});

app.listen(process.env.PORT || 8080);
